import abc
import asyncio
import logging
import time

try:
  from .Status import Status
  from .Method import Method
  from .Message import RequestMessage, ResponseMessage
except ImportError:
  from asynchttpserver.Status import Status
  from asynchttpserver.Method import Method
  from asynchttpserver.Message import RequestMessage, ResponseMessage

# Configuration limits
MAX_HEADER_SIZE = 4096 
MAX_BODY_SIZE = 1024 * 64 
READ_TIMEOUT = 10 

class AsyncRequestHandler(abc.ABC):
  """Abstract base class for handling asynchronous HTTP requests."""
  @abc.abstractmethod
  async def handle(self, request: RequestMessage) -> ResponseMessage:
    pass

class AsyncRequestResponseHandler(AsyncRequestHandler):
  """A concrete request handler that uses a callback to generate a response."""
  def __init__(self, callback):
    self._callback = callback

  async def handle(self, request: RequestMessage) -> ResponseMessage:
    return await self._callback(request)

class AsyncRequestRouteHandler(AsyncRequestHandler):
  """
  A request handler that routes requests to other handlers based on path and method.
  Supports Flask-like decorators.
  """
  def __init__(self, logger: logging.Logger | None = None):
    # Structure: { "GET": {"/path": handler}, ... }
    self._routes: dict[str, dict[str, AsyncRequestHandler]] = {}
    self.logger = logger

  def add_route(self, path: str, handler: AsyncRequestHandler, methods: list[Method] | None = None):
    """
    Registers a handler for a specific path and a list of methods.
    
    Args:
      path (str): The URL path.
      handler (AsyncRequestHandler): The handler instance.
      methods (list[Method], optional): List of accepted methods. Defaults to [Method.GET].
    """
    if methods is None:
      methods = [Method.GET]
      
    for method in methods:
      method_name = method.name
      if method_name not in self._routes:
        self._routes[method_name] = {}
      self._routes[method_name][path] = handler

  def route(self, path: str, methods: list[Method] = [Method.GET]):
    """
    Decorator to register a function as a route handler.
    
    Args:
      path (str): The URL path.
      methods (list[Method], optional): The HTTP method(s) to accept. Defaults to [Method.GET].
    """
    def decorator(handler):
      _handler = AsyncRequestResponseHandler(handler)
      self.add_route(path, _handler, methods)
      return handler
    return decorator

  def mount(self, path: str, methods: list[Method] = [Method.GET]):
    """
    Decorator to mount a Sub-Router (or any AsyncRequestHandler) generated by a function.
    The decorated function should return an instance of AsyncRequestHandler.
    
    Args:
      path (str): The URL path prefix.
      methods (list[Method], optional): The HTTP method(s) to accept. Defaults to [Method.GET].
    
    Usage:
      @app.mount("/api", methods=[Method.GET, Method.POST])
      def register_api():
          api = AsyncRequestRouteHandler()
          # ... setup api ...
          return api
    """
    def decorator(func):
      # Execute the function to get the handler instance (e.g. the sub-router)
      handler = func()
      if not isinstance(handler, AsyncRequestHandler):
          raise TypeError(f"Mounted function {func.__name__} must return an AsyncRequestHandler")
      self.add_route(path, handler, methods)
      return handler # Return the handler so it can be used if needed
    return decorator

  async def handle(self, request: RequestMessage) -> ResponseMessage:
    method_routes = self._routes.get(request.method.name, {})
    
    best_match_path = ""
    handler = None
    
    for path, registered_handler in method_routes.items():
      if request.path == path:
        best_match_path = path
        handler = registered_handler
        break 
      
      if path == "/" or (request.path.startswith(path) and request.path[len(path)] == '/'):
        if len(path) > len(best_match_path):
          best_match_path = path
          handler = registered_handler
          
    if handler:
      if self.logger: self.logger.debug(f"Routing {request.method.name} {request.path} to {handler}")
      
      sub_path = request.path[len(best_match_path):]
      if not sub_path.startswith("/"):
          sub_path = "/" + sub_path
          
      modified_request = RequestMessage(
        method=request.method,
        path=sub_path,
        header=request.header,
        body=request.body,
        version=request.version
      )
      return await handler.handle(modified_request)
    else:
      if self.logger: self.logger.debug(f"No route found for {request.method.name} {request.path}")
      return ResponseMessage(
        status=Status.NOT_FOUND,
        header={"Content-Type": "text/plain", "Connection": "close"},
        body=b"404 Not Found"
      )

class AsyncServer:
  """An asynchronous HTTP server."""
  def __init__(self, root_handler: AsyncRequestHandler, host: str = '0.0.0.0', port: int = 80, logger: logging.Logger | None = None):
    self.root_handler = root_handler
    self.host = host
    self.port = port
    self.logger = logger
    self._server = None

  async def _handle_connection(self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter):
    addr = writer.get_extra_info('peername')
    if self.logger: self.logger.info(f"New connection from {addr}")

    try:
      header_bytes = b""
      total_header_len = 0
      
      while True:
        try:
            line = await asyncio.wait_for(reader.readline(), READ_TIMEOUT)
        except asyncio.TimeoutError:
            if self.logger: self.logger.warning("Timeout waiting for headers")
            return 

        if not line: return

        total_header_len += len(line)
        if total_header_len > MAX_HEADER_SIZE:
           raise ValueError("Header too large")

        header_bytes += line
        if line == b'\r\n':
          break

      request = RequestMessage.unpack_header(header_bytes)
      content_len = int(request.header.get('content-length', 0))
      
      if content_len > MAX_BODY_SIZE:
          raise ValueError(f"Body too large ({content_len} > {MAX_BODY_SIZE})")
      
      if content_len > 0:
        try:
            body_data = await asyncio.wait_for(reader.readexactly(content_len), READ_TIMEOUT)
            request.body = body_data
        except asyncio.TimeoutError:
             if self.logger: self.logger.warning("Timeout waiting for body")
             return

      response = await self.root_handler.handle(request)
      
      writer.write(response.pack())
      await writer.drain()

    except ValueError as e:
      if self.logger: self.logger.error(f"Invalid request: {e}")
      err_resp = ResponseMessage(Status.BAD_REQUEST, {"Connection": "close"}, b"400 Bad Request")
      writer.write(err_resp.pack())
      await writer.drain()
      
    except Exception as e:
      if self.logger: self.logger.error(f"Internal Error: {e}")
      err_resp = ResponseMessage(Status.INTERNAL_SERVER_ERROR, {"Connection": "close"}, b"500 Internal Server Error")
      writer.write(err_resp.pack())
      await writer.drain()
      
    finally:
      try:
        writer.close()
        await writer.wait_closed()
      except Exception:
        pass
      if self.logger: self.logger.debug(f"Connection closed {addr}")

  async def start(self):
    if self._server: return
    self._server = await asyncio.start_server(self._handle_connection, self.host, self.port)
    if self.logger: self.logger.info(f"Server started on {self.host}:{self.port}")

  async def stop(self):
    if self._server:
      self._server.close()
      await self._server.wait_closed()
      self._server = None
      if self.logger: self.logger.info("Server stopped")